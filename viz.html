<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style>
			html, body {
				margin: 0;
				padding: 0;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script src="three.min.js"></script>
		<script src="TrackballControls.js"></script>
		<script>
			var container, stats;
			var camera, controls, scene, renderer;

			init();
			animate();

			let tubeMaterial = new THREE.MeshPhongMaterial({
		      transparent: true,
		      opacity: 0.8,
		      blending: THREE.AdditiveBlending,
		      color: 0xffffff,
		      side: THREE.BackSide,
		    });

			function init() {
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 15000 );
				camera.position.x = 0;
				camera.position.y = -6000;
				camera.position.z = 6000;

				controls = new THREE.TrackballControls( camera );

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener( 'change', render );

				// world

				scene = new THREE.Scene();
				var material =  new THREE.MeshPhongMaterial( { color:0xffffff, shading: THREE.FlatShading } );


				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setClearColor( 0x404040 );
				const light = new THREE.AmbientLight( 0x404040 ); // soft white light
				scene.add( light );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				function drawCylinder(vstart, vend,scene){
				    var HALF_PI = Math.PI * .5;
				    var distance = vstart.distanceTo(vend);
				    var position  = vend.clone().add(vstart).divideScalar(2);

				    var cylinder = new THREE.CylinderGeometry(10,10,distance,10,10,false);

				    var orientation = new THREE.Matrix4();//a new orientation matrix to offset pivot
				    var offsetRotation = new THREE.Matrix4();//a matrix to fix pivot rotation
				    var offsetPosition = new THREE.Matrix4();//a matrix to fix pivot position
				    orientation.lookAt(vstart,vend,new THREE.Vector3(0,1,0));//look at destination
				    offsetRotation.makeRotationX(HALF_PI);//rotate 90 degs on X
				    orientation.multiply(offsetRotation);//combine orientation with rotation transformations
				    cylinder.applyMatrix(orientation)

				    var mesh = new THREE.Mesh(cylinder,tubeMaterial);
				    mesh.position.copy( position );
				    scene.add(mesh);
				}


				let facets, vertexes, vertexGroups = [], edges=[];
				fetch("dome.stl").then(r=>r.text()).then(function(data) {
					let facetsRe = /^facet(.+\n){6}endfacet/mg;
					facets = data.match(facetsRe);
					let vertexRe = /vertex( [e0-9.-]+){3}/g;
					vertexes = data.match(vertexRe).map(l=>l.split(" ")).map(([_, x, y, z]) => [x, y, z].map(parseFloat));

					facets.forEach((f,i)=>{
						let localVertexes = f.match(vertexRe).map(l=>l.split(" ")).map(([_, x, y, z]) => [x, y, z].map(parseFloat));
						vertexGroups.push(localVertexes);
					});

					vertexGroups.forEach(vg=>{edges.push([[vg[0], vg[1]],[vg[1], vg[2]],[vg[2], vg[0]]])});
					edges = edges.flat()
					edges = edges.map(e=>e.sort((a,b)=>a<b));
					let jsonedges = edges.map(e=>JSON.stringify(e))
					let uniqueEdges = [...new Set(jsonedges)].map(je=>JSON.parse(je).map(v=>new THREE.Vector3(...v)));
					let tubeMaterial = new THREE.MeshPhongMaterial({color:0xff0000});
					let LEDDistance = 60;
					let totalLEDs = 0;
					console.log({uniqueEdges})
					uniqueEdges.forEach(ue => {
						drawCylinder(ue[0], ue[1], scene);
						// let distance = ue[0].distanceTo(ue[1]);
						// let LEDCount = Math.floor(distance / LEDDistance);
						// totalLEDs += LEDCount;
						// let offsetDistance = (distance % LEDDistance) / 2;
						// let directionVector = ue[0].sub(ue[1]).normalize();
						// let offsetVector = directionVector.clone().multiplyScalar(offsetDistance);
						// let LEDVector = directionVector.clone().multiplyScalar(LEDDistance);
						// for (let idx = 0; idx < LEDCount; idx++) {
						// 	let pointLight = new THREE.PointLight(new THREE.Color(`hsl(${360/LEDCount*idx}, 100%, 50%)`));
						// 	pointLight.position.copy(ue[0].clone().add(offsetVector).add(LEDVector.multiplyScalar(idx)));
						// 	scene.add(pointLight);
						// }
					});
					console.log({totalLEDs});
				});

				render();
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();

				render();
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update();
			}

			function render() {
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>